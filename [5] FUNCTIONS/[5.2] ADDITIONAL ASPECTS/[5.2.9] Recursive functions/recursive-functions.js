/**
 * Полное руководство по функциям для Junior JS Developer
 *
 * Глава: Дополнительные аспекты
 * Подглава: Рекурсивные функции
 */

/**
 * Введение
 *
 * Рекурсивные функции - это функции, которые вызывают сами себя. Они полезны для решения задач,
 * которые могут быть разбиты на более простые подзадачи. Рекурсия широко используется в алгоритмах,
 * таких как обход деревьев, сортировка и другие.
 */

/**
 * Основы рекурсии
 *
 * Рекурсивная функция должна иметь условие завершения, чтобы избежать бесконечного цикла.
 * Условие завершения определяет, когда функция должна прекратить вызывать саму себя.
 *
 * Пример:
 */
function factorial(n) {
    if (n <= 1) return 1; // Условие завершения
    return n * factorial(n - 1); // Рекурсивный вызов
}

console.log(factorial(5)); // Вывод: 120

/**
 * Рекурсивный обход дерева
 *
 * Рекурсия часто используется для обхода структур данных, таких как деревья.
 *
 * Пример:
 */
const tree = {
    value: 1,
    left: {
        value: 2,
        left: {
            value: 4
        },
        right: {
            value: 5
        }
    },
    right: {
        value: 3
    }
};

function traverseTree(node) {
    if (node == null) return; // Условие завершения
    console.log(node.value); // Обработка узла
    traverseTree(node.left); // Рекурсивный вызов для левого поддерева
    traverseTree(node.right); // Рекурсивный вызов для правого поддерева
}

traverseTree(tree);
// Вывод:
// 1
// 2
// 4
// 5
// 3

/**
 * Рекурсивное вычисление чисел Фибоначчи
 *
 * Функция для вычисления чисел Фибоначчи также может быть реализована с использованием рекурсии.
 *
 * Пример:
 */
function fibonacci(n) {
    if (n <= 1) return n; // Условие завершения
    return fibonacci(n - 1) + fibonacci(n - 2); // Рекурсивный вызов
}

console.log(fibonacci(6)); // Вывод: 8

/**
 * Хвостовая рекурсия
 *
 * Хвостовая рекурсия - это особый вид рекурсии, при котором рекурсивный вызов является последней
 * операцией в функции. Некоторые интерпретаторы JavaScript могут оптимизировать хвостовую рекурсию,
 * чтобы избежать переполнения стека вызовов.
 *
 * Пример:
 */
function factorialTailRecursive(n, acc = 1) {
    if (n <= 1) return acc; // Условие завершения
    return factorialTailRecursive(n - 1, n * acc); // Рекурсивный вызов
}

console.log(factorialTailRecursive(5)); // Вывод: 120

/**
 * Преимущества и недостатки рекурсии
 *
 * Преимущества:
 * - Простота и выразительность для задач, которые естественным образом разбиваются на подзадачи.
 * - Удобство для работы с рекурсивными структурами данных (деревья, графы).
 *
 * Недостатки:
 * - Возможность переполнения стека вызовов при слишком глубокой рекурсии.
 * - Рекурсивные решения могут быть менее эффективными по сравнению с итеративными аналогами.
 */

/**
 * Заключение
 *
 * Рекурсивные функции являются мощным инструментом в JavaScript, позволяющим элегантно решать задачи,
 * которые можно разбить на более простые подзадачи. Понимание рекурсии и её применений помогает писать
 * более чистый и понятный код для сложных алгоритмов.
 */

