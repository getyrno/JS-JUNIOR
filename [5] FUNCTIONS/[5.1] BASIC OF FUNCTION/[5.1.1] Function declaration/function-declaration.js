/**
 * Полная документация по объявлению функций в JavaScript
 *
 * Функции в JavaScript являются важным элементом языка и позволяют вам
 * структурировать и повторно использовать код. Существует несколько способов
 * объявить функции, каждый из которых имеет свои особенности и применение.
 */

/**
 * Объявление функции (Function Declaration)
 *
 * Этот способ объявляет функцию с именем, которое может быть использовано для вызова
 * этой функции. Объявленные таким образом функции "поднимаются" (hoisted) наверх
 * текущей области видимости, что позволяет их вызывать до момента объявления.
 *
 * Пример:
 */
function greet() {
    console.log('Привет!');
}

// Вызов функции
greet(); // Вывод: Привет!

/**
 * Функциональное выражение (Function Expression)
 *
 * Функциональные выражения создают функции внутри выражений. Эти функции не
 * поднимаются наверх области видимости, как объявления функций. Они могут быть
 * анонимными или иметь имя.
 *
 * Пример:
 */
const greetExpression = function() {
    console.log('Привет от функционального выражения!');
};

// Вызов функции
greetExpression(); // Вывод: Привет от функционального выражения!

/**
 * Стрелочные функции (Arrow Functions)
 *
 * Стрелочные функции предоставляют краткий синтаксис для написания функций и
 * автоматически связывают контекст `this` в момент создания функции. Они не
 * имеют своего контекста `this`, `arguments`, `super` и `new.target`.
 *
 * Пример:
 */
const greetArrow = () => {
    console.log('Привет от стрелочной функции!');
};

// Вызов функции
greetArrow(); // Вывод: Привет от стрелочной функции!

/**
 * Параметры и аргументы
 *
 * Функции могут принимать параметры, которые передаются при вызове функции.
 * Значения передаются в виде аргументов.
 *
 * Пример:
 */
function greetWithName(name) {
    console.log('Привет, ' + name + '!');
}

// Вызов функции с аргументом
greetWithName('Алиса'); // Вывод: Привет, Алиса!

/**
 * Параметры по умолчанию
 *
 * Вы можете задать значения по умолчанию для параметров функции, которые будут
 * использоваться, если аргументы не были переданы при вызове функции.
 *
 * Пример:
 */
function greetWithDefault(name = 'гость') {
    console.log('Привет, ' + name + '!');
}

// Вызов функции без аргумента
greetWithDefault(); // Вывод: Привет, гость!

// Вызов функции с аргументом
greetWithDefault('Алиса'); // Вывод: Привет, Алиса!

/**
 * Остаточные параметры (Rest Parameters)
 *
 * Остаточные параметры позволяют функции принимать переменное количество аргументов
 * в виде массива.
 *
 * Пример:
 */
function sum(...numbers) {
    return numbers.reduce((acc, curr) => acc + curr, 0);
}

// Вызов функции с несколькими аргументами
console.log(sum(1, 2, 3)); // Вывод: 6

/**
 * Анонимные функции (Anonymous Functions)
 *
 * Анонимные функции - это функции, которые не имеют имени. Они часто используются
 * в качестве аргументов для других функций.
 *
 * Пример:
 */
setTimeout(function() {
    console.log('Это анонимная функция!');
}, 1000);

/**
 * Немедленно вызываемые функциональные выражения (IIFE)
 *
 * Немедленно вызываемые функциональные выражения позволяют создавать функции, которые
 * немедленно выполняются после их определения. Это полезно для создания изолированной
 * области видимости.
 *
 * Пример:
 */
(function() {
    console.log('Это IIFE!');
})();

/**
 * Исключения и особенности функций
 *
 * JavaScript функции имеют несколько особенностей и возможностей, которые важно учитывать.
 */

/**
 * Hoisting (поднятие)
 *
 * Объявления функций (function declarations) поднимаются наверх области видимости,
 * что позволяет их использовать до момента фактического объявления в коде.
 *
 * Пример:
 */
hoistedFunction(); // Вывод: Функция поднята!
function hoistedFunction() {
    console.log('Функция поднята!');
}

/**
 * Функции как объекты первого класса (First-Class Objects)
 *
 * В JavaScript функции являются объектами первого класса, что означает, что их можно
 * присваивать переменным, передавать в качестве аргументов другим функциям и возвращать
 * из функций.
 *
 * Пример:
 */
function sayHello() {
    return function() {
        console.log('Привет из возвращенной функции!');
    };
}

const newFunction = sayHello();
newFunction(); // Вывод: Привет из возвращенной функции!

/**
 * Callback функции (Callback Functions)
 *
 * Callback функции передаются как аргументы другим функциям и вызываются по завершению
 * определенного действия.
 *
 * Пример:
 */
function fetchData(callback) {
    setTimeout(() => {
        callback('Данные получены!');
    }, 2000);
}

fetchData((message) => {
    console.log(message); // Вывод: Данные получены!
});

/**
 * Замыкания (Closures)
 *
 * Замыкания возникают, когда функция сохраняет ссылку на область видимости, в которой она была создана.
 * Это позволяет функции иметь доступ к переменным из внешней области видимости даже после завершения
 * выполнения этой области.
 *
 * Пример:
 */
function createCounter() {
    let count = 0;
    return function() {
        count += 1;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // Вывод: 1
console.log(counter()); // Вывод: 2

/**
 * Архитектурные решения
 *
 * В JavaScript функции могут использоваться для реализации различных архитектурных паттернов.
 */

/**
 * Модульный паттерн (Module Pattern)
 *
 * Модульный паттерн используется для создания замкнутых областей видимости и инкапсуляции кода.
 * Это помогает разделить код на независимые модули.
 *
 * Пример:
 */
const Module = (function() {
    let privateVar = 'Это приватная переменная';

    function privateFunction() {
        console.log(privateVar);
    }

    return {
        publicMethod: function() {
            privateFunction();
        }
    };
})();

Module.publicMethod(); // Вывод: Это приватная переменная

/**
 * Каррирование (Currying)
 *
 * Каррирование - это техника, когда функция, которая принимает несколько аргументов, преобразуется
 * в последовательность функций, каждая из которых принимает один аргумент.
 *
 * Пример:
 */
function add(a) {
    return function(b) {
        return a + b;
    };
}

const addFive = add(5);
console.log(addFive(3)); // Вывод: 8

/**
 * Функциональное программирование (Functional Programming)
 *
 * Функции в JavaScript поддерживают функциональное программирование, включая такие концепции,
 * как функции высшего порядка и чистые функции.
 *
 * Пример:
 */
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map((number) => number * 2);
console.log(doubled); // Вывод: [2, 4, 6, 8, 10]

const sumNumbers = numbers.reduce((acc, number) => acc + number, 0);
console.log(sumNumbers); // Вывод: 15
